package argon2id

import (
	"crypto/subtle"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"strings"

	"github.com/melsincostan/argon2id/utils"
	"golang.org/x/crypto/argon2"
)

var (
	// ErrUnparseableHash is returned when the Deserialize function of the struct thinks the provided input isn't in the format it expects.
	// Specifically, it means removing the leading "$" and splitting the string on the "$" character didn't yield 5 elements.
	ErrUnparseableHash = errors.New("hash format not understood or invalid")
	// ErrUnsupportedAlgorithm is returned by the Deserialize function when the provided algorithm isn't the specified algorithm.
	ErrUnsupportedAlgorithm = fmt.Errorf("only the %s algorithm is supported", supportedAlg)
	// ErrVersionNotFound is returned when the third element of a string that is being deserialized doesn't have a 'v' key.
	ErrVersionNotFound = errors.New("couldn't find the version key (v)")
	// ErrIterationsNotFound is returned when the fourth element of a string that is being deserialized doesn't have a 't' key.
	ErrIterationsNotFound = errors.New("couldn't find the iterations key (t)")
	// ErrVersionNotFound is returned when the fourth element of a string that is being deserialized doesn't have a 'p' key.
	ErrParallelismNotFound = errors.New("couldn't find the parallelism key (p)")
	// ErrVersionNotFound is returned when the fourth element of a string that is being deserialized doesn't have a 'm' key.
	ErrMemoryNotFound = errors.New("couldn't find the memory key (m)")
)

const (
	// supportedAlg is the supported algorithm. It should be argon2id.
	supportedAlg = "argon2id"
)

// HObject represents an argon2id hash, with all necessary informations to check a password against it and serialize it for storage.
type HObject struct {
	// Hash is the result of running the password through argon2id.
	Hash []byte
	// Salt is the salt used when creating the hash.
	Salt []byte
	// Memory is the memory (m) parameter of the argon2id algorithm.
	Memory uint32
	// Iterations is the time (t) parameter of the argon2id algorithm.
	Iterations uint32
	// Parallelism is the parallelism (p) / Threads parameter of the argon2id algorithm.
	Parallelism uint8
	// Version is the version of the argon2 algorithm used.
	// In this case, this would usually be argon2.Version.
	Version string
	// Algorithm is the algorithm used.
	// It should always be argon2id.
	Algorithm string
}

// Compare checks a password against the current hash.
// If they match, it returns true.
// Otherwise, it returns false.
// This uses subtle.ConstantTimeCompare to compare the hashes, to hopefully avoid timing attacks.
func (ho HObject) Compare(passwd string) bool {
	cmph := argon2.IDKey([]byte(passwd), ho.Salt, ho.Iterations, ho.Memory, ho.Parallelism, uint32(len(ho.Hash)))
	return subtle.ConstantTimeCompare(cmph, ho.Hash) == 1
}

// MarshalJSON is a wrapper around the Serialize method to be compatible with encoding/json.
func (ho HObject) MarshalJSON() ([]byte, error) {
	return []byte(ho.Serialize()), nil
}

// UnmarshalJSON is a wrapper around the Deserialize method to be compatible with encoding/json.
func (ho *HObject) UnmarshalJSON(in []byte) error {
	var s string
	if err := json.Unmarshal(in, &s); err != nil {
		return err
	}
	return ho.Deserialize(s)
}

// Serialize returns a string representation of the hash object.
// The string representation is of the form:
// $argon2id$v={version}$m={memory},t={iterations},p={parallelism}${base64 salt}${base64 hash}
func (ho HObject) Serialize() string {
	hashEnc := base64.RawStdEncoding.EncodeToString(ho.Hash)
	saltEnc := base64.RawStdEncoding.EncodeToString(ho.Salt)
	return fmt.Sprintf("$%s$v=%s$m=%d,t=%d,p=%d$%s$%s", ho.Algorithm, ho.Version, ho.Memory, ho.Iterations, ho.Parallelism, saltEnc, hashEnc)
}

// Deserialize takes in a string in the format generated by Serialize, and fills the struct with the provided information.
// In case this isn't possible, an error is returned.
func (ho *HObject) Deserialize(in string) error {
	spl := strings.Split(strings.TrimPrefix(in, "$"), "$")
	if len(spl) != 5 {
		return ErrUnparseableHash
	}

	if spl[0] != supportedAlg {
		return ErrUnsupportedAlgorithm
	}

	ho.Algorithm = spl[0]

	vm, err := utils.ToMap[string](spl[1])
	if err != nil {
		return err
	}

	if ver, ok := vm["v"]; ok {
		ho.Version = ver
	} else {
		return ErrVersionNotFound
	}

	pm, err := utils.ToMap[uint64](spl[2])
	if err != nil {
		return err
	}

	if mem, ok := pm["m"]; ok {
		ho.Memory = uint32(mem)
	} else {
		return ErrMemoryNotFound
	}

	if iters, ok := pm["t"]; ok {
		ho.Iterations = uint32(iters)
	} else {
		return ErrIterationsNotFound
	}

	if par, ok := pm["p"]; ok {
		ho.Parallelism = uint8(par)
	} else {
		return ErrParallelismNotFound
	}

	salt, err := base64.RawStdEncoding.DecodeString(spl[3])

	if err != nil {
		return err
	}

	ho.Salt = salt

	hash, err := base64.RawStdEncoding.DecodeString(spl[4])

	if err != nil {
		return err
	}

	ho.Hash = hash

	return nil
}
